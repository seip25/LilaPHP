<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>LilaPHP ‚Äî Lightweight Modern PHP Framework</title>

  <meta name="description"
    content="LilaPHP is a lightweight, modular, and modern PHP micro-framework focused on simplicity, flexibility, and security. It includes clean routing, middleware, Twig templates, and Dotenv configuration for building fast, maintainable web applications." />
  <meta name="keywords"
    content="LilaPHP, PHP microframework, lightweight PHP framework, modern PHP, minimal framework, PHP routing, Twig, Dotenv, PHP middleware, Lila, seip25" />
  <meta name="author" content="LilaPHP Project" />
  <meta name="robots" content="index, follow" />

  <!-- Canonical -->
  <link rel="canonical" href="https://seip25.github.io/LilaPHP/" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="img/lila.png" />

  <!-- Styles -->
  <link rel="stylesheet" href="css/lila.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css" />

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://seip25.github.io/LilaPHP/" />
  <meta property="og:title" content="LilaPHP ‚Äî Lightweight Modern PHP Framework" />
  <meta property="og:description"
    content="LilaPHP is a lightweight and modular PHP framework built for simplicity, flexibility, and performance. Clean routing, middleware, Twig, and more." />
  <meta property="og:image" content="https://seip25.github.io/LilaPHP/img/lila.png" />

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image" />
  <meta property="twitter:title" content="LilaPHP ‚Äî Lightweight Modern PHP Framework" />
  <meta property="twitter:description"
    content="Modern lightweight PHP framework for developers who love simplicity and power. Includes routing, Twig templates, and Dotenv." />
  <meta property="twitter:image" content="https://seip25.github.io/LilaPHP/img/lila.png" />

  <!-- Structured Data -->
  <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "LilaPHP",
        "operatingSystem": "Cross-platform",
        "applicationCategory": "WebApplicationFramework",
        "description": "LilaPHP is a lightweight, modular PHP framework focused on simplicity, flexibility, and performance. Includes routing, Twig, and Dotenv integration.",
        "url": "https://seip25.github.io/LilaPHP/",
        "softwareVersion": "1.0.0",
        "author": {
          "@type": "Person",
          "name": "Andr√©s Paiva"
        },
        "publisher": {
          "@type": "Organization",
          "name": "LilaPHP Project"
        },
        "image": "https://seip25.github.io/LilaPHP/img/lila.png"
      }
    </script>
  <style>
  
  </style>
</head>


<body>


  <main class="mt-4 px-4">
    <div class="flex gap-4">
      <aside class="docs-nav hidden-sm px-aside">
        <h4>Core</h4>
        <a href="#introduction">Introduction</a>
        <a href="#install">Installation</a>
        <a href="#structure">Structure</a>
        <a href="#routing">Routing</a>
        <a href="#validation">Validation</a>
        <a href="#sessions">Sessions</a>
        <a href="#localization">Translations</a>
        <a href="#config">Environment</a>
        <a href="#security">Security</a>
        <a href="#templates">Twig Functions</a>
        <a href="#seo">SEO</a>
        <a href="#performance">Performance</a>
        <a href="#coreapp">The App Core</a>
        <a href="#production">Production</a>
      </aside>

      <div class="grid gap-4">
        <div class=" visible-sm grid gap-4 text-center ">
        <div><a href="#introduction" class="text-gray-500">Introduction</a></div>
        <div><a href="#install" class="text-gray-500">Installation</a></div>
        <div><a href="#structure" class="text-gray-500">Structure</a></div>
        <div><a href="#routing" class="text-gray-500">Routing</a></div>
        <div><a href="#validation" class="text-gray-500">Validation</a></div>
        <div><a href="#sessions" class="text-gray-500">Sessions</a></div>
        <div><a href="#localization" class="text-gray-500">Translations</a></div>
        <div><a href="#config" class="text-gray-500">Environment</a></div>
        <div><a href="#security" class="text-gray-500">Security</a></div>
        <div><a href="#templates" class="text-gray-500">Twig Functions</a></div>
        <div><a href="#seo" class="text-gray-500">SEO</a></div>
        <div><a href="#performance" class="text-gray-500">Performance</a></div>
        <div><a href="#coreapp" class="text-gray-500">App Core</a></div>
        <div> <a href="#production" class="text-gray-500">Production</a></div>
     </div>

      <div>

        <!-- Introduction -->
        <section id="introduction" class="mt-4">
          <article class="bg-surface border-none">
            <h1 class="text-indigo-500">LilaPHP Framework</h1>
            <p class="text-secondary">
              <strong>LilaPHP</strong> is a lightweight and modular PHP micro-framework designed for
              simplicity, flexibility, and security.
            </p>
            <p>
              It provides a minimal yet powerful foundation for building web applications with
              <strong>clean routing</strong>, <strong>middleware</strong>, <strong>Twig templates</strong>,
              and <strong>Dotenv configuration</strong>.
            </p>
            <p>
              LilaPHP gives you control and performance ‚Äî no boilerplate, no heavy dependencies,
              just clean, fast PHP.
            </p>
          </article>
          <footer>
            <a href="https://github.com/seip25/LilaPHP" target="_blank" class="text-indigo-500">
              ‚≠ê View LilaPHP on GitHub
            </a>
          </footer>

          <!-- Why Choose LilaPHP -->
          <!-- Why Choose LilaPHP -->
<section id="why-lilaphp" class="mt-4">
  <article class="bg-surface border-none">
    <h2 class="text-indigo-500">Why Choose LilaPHP?</h2>

    <p>
      <strong>LilaPHP</strong> was designed with one clear purpose ‚Äî to give
      developers full control, performance, and simplicity without the
      unnecessary overhead of large, opinionated frameworks.
    </p>

    <p>
      Its modular architecture allows every <strong>endpoint</strong>,
      <strong>view</strong>, or <strong>micro-app</strong> to be completely
      independent and configurable. You can have one route using CORS,
      sessions, and translations ‚Äî and another one running without any of them.
      This flexibility is what makes LilaPHP both <strong>powerful</strong> and
      <strong>lightweight</strong>.
    </p>

    <p>
      In traditional frameworks, most configurations are global and apply to the
      entire project. In contrast, LilaPHP loads only what each request needs.
      This means lower memory usage, faster execution, and cleaner architecture.
    </p>

    <h3>Example: Different Configurations per Entry Point</h3>

    <p>
      Each entry file can instantiate the framework with its own configuration,
      giving you complete control over security, middleware, and session
      behavior.
    </p>

    <pre><code class="language-php">// app/index.php
namespace App;

require_once __DIR__ . "/vendor/autoload.php";

use Core\App;

$app = new App(); // Default configuration (security, sessions, translations, etc.)
</code></pre>

    <pre><code class="language-php">// app/newApp.php
namespace App;

require_once __DIR__ . "/vendor/autoload.php";

use Core\App;

// Custom configuration - CORS disabled, no sanitization, no session
$app = new App([
    'security' => [
        'cors' => false,
        'sanitize' => false,
        'logger' => true
    ]
]);

// From here you can register custom routes, templates, or middlewares
$app->get(callback: fn($req, $res) => $app->render("newApp"));
$app->run();
</code></pre>

    <p>
      Thanks to this modularity, each mini-application can behave differently ‚Äî
      one can serve public APIs, another can manage admin panels, and another
      can handle localized front-end pages ‚Äî all within the same project folder.
    </p>

    <ul class="list-disc pl-6 mt-2">
      <li>
        ‚ö° <strong>Lightweight core:</strong> Loads only what‚Äôs needed for each
        request ‚Äî no redundant processing or duplicate execution.
      </li>
      <li>
        üß© <strong>Modular structure:</strong> Each app, route, or endpoint can
        define its own configuration, middlewares, and translations.
      </li>
      <li>
        üîí <strong>Secure by default:</strong> Built-in CSRF protection, input
        sanitization, isolated session handling, and configurable CORS.
      </li>
      <li>
        ü™∂ <strong>SEO-friendly:</strong> Clean URLs, optimized image helpers,
        and auto-generated metadata.
      </li>
      <li>
        üñ•Ô∏è <strong>Universal compatibility:</strong> Works seamlessly on
        <strong>NGINX</strong>, <strong>Apache</strong>,
        <strong>FrankenPHP</strong>, <strong>Swoole</strong>,
        <strong>VPS</strong>, <strong>local network</strong>, or
        <strong>shared hosting</strong>.
      </li>
      <li>
        üß† <strong>Developer experience first:</strong> Instant setup, clear
        routing, localized validation, and intuitive Twig integration.
      </li>
      <li>
        üöÄ <strong>Performance oriented:</strong> Minimal I/O, cached helpers,
        and pre-optimized rendering for production.
      </li>
    </ul>

    <p class="mt-4">
      With <strong>DEBUG=false</strong> in production,
      <strong>LilaPHP</strong> automatically switches to optimized mode,
      generating minified HTML, caching Twig templates, and loading only what‚Äôs
      necessary per route.
    </p>

    <p class="text-secondary mt-2">
      Each request remains lightweight, secure, and fully isolated ‚Äî resulting
      in <strong>extreme performance</strong> with <strong>minimal CPU and
      memory usage</strong>.
    </p>
  </article>
</section>


        </section>




        <!-- Installation -->
        <section id="install" class="mt-4">
          <h2>Installation</h2>
          <p>
            LilaPHP is designed to run on any standard PHP environment. You can use the
            built-in PHP server for quick development or configure Apache/NGINX for
            production environments.
          </p>

          <h3>1Ô∏è‚É£ Clone the Repository</h3>
          <pre><code class="language-bash">git clone https://github.com/seip25/LilaPHP.git</code></pre>

          <h3>2Ô∏è‚É£ Install Dependencies</h3>
          <p>Navigate to the <code>app</code> directory and install dependencies via Composer:</p>
          <pre><code class="language-bash">cd app && composer install</code></pre>

          <h3>3Ô∏è‚É£ Configure Environment Variables</h3>
          <p>Copy the example environment file and modify it according to your setup:</p>
          <pre><code class="language-bash">cp .env.example .env</code></pre>

          <p>Edit <code>.env</code> and update the base URL (for example, when running locally):</p>
          <pre><code class="language-env">URL_PROJECT="http://localhost:8000/"</code></pre>

          <p>
            You can also set database credentials, timezone, and debug mode from the same
            file.
          </p>

          <h3>4Ô∏è‚É£ Run the Application</h3>
          <p>There are multiple ways to start your application depending on your environment:</p>

          <h4>‚û°Ô∏è Using PHP's Built-in Server (Recommended for Development)</h4>
           <pre><code class="language-bash">cd .. </code></pre>
          <pre><code class="language-bash">php -S localhost:8000 </code></pre>

          <p>
            Then visit <a href="http://localhost:8000" target="_blank">http://localhost:8000</a>
            in your browser.
          </p>

          <h4>‚û°Ô∏è Using XAMPP / LAMPP / WAMP</h4>
          <ol>
            <li>Place your project inside the <code>htdocs</code> or <code>www</code> folder.</li>
            <li>Start Apache and MySQL from your control panel.</li>
            <li>Access your app at <code>http://localhost/LilaPHP/</code> (or your chosen folder name).</li>
          </ol>
          <p>
            Make sure <code>URL_PROJECT</code> in your <code>.env</code> file matches this path:
          </p>
          <pre><code class="language-env">URL_PROJECT="http://localhost/LilaPHP/"</code></pre>

          <h4>‚û°Ô∏è Using NGINX (Recommended for Production)</h4>
          <p>Add a server block like this:</p>
          <pre><code class="language-nginx">server {
    listen 80;
    server_name example.com;
    root /var/www/LilaPHP/;

    index index.php;
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/run/php/php8.2-fpm.sock;
    }

    location /app {
        deny all;
    }
}</code></pre>

          <p>
            Restart NGINX after saving changes, and make sure to update your
            <code>URL_PROJECT</code> to your domain:
          </p>
          <pre><code class="language-env">URL_PROJECT="https://example.com/"</code></pre>

          <h4>‚û°Ô∏è Using Apache (.htaccess)</h4>
          <p>Ensure <code>mod_rewrite</code> is enabled, and your <code>.htaccess</code> contains:</p>
          <pre><code class="language-apache">&lt;IfModule mod_rewrite.c&gt;
  RewriteEngine On
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule ^ index.php [L]
&lt;/IfModule&gt;</code></pre>

          <p>Then configure your virtual host to point to the <code>public/</code> directory:</p>
          <pre><code class="language-apache">&lt;VirtualHost *:80&gt;
  DocumentRoot "/var/www/LilaPHP/"
  ServerName example.local
&lt;/VirtualHost&gt;</code></pre>

          <p>
            Restart Apache and update your <code>URL_PROJECT</code> accordingly.
          </p>

          <hr class="my-4 border-gray-300" />
          <p class="text-secondary">
            ‚úÖ After setup, visit your configured URL to see LilaPHP running.
          </p>
        </section>


        <!-- Structure -->
        <section id="structure" class="mt-4">
          <h2>Project Structure</h2>
          <pre><code class="language-bash">LilaPHP/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ core/          # Core framework files (router, response, validator)
‚îÇ   ‚îú‚îÄ‚îÄ templates/     # Twig templates
‚îÇ   ‚îú‚îÄ‚îÄ locales/       # Language files
‚îÇ   ‚îú‚îÄ‚îÄ vendor/        # Composer dependencies
‚îÇ   ‚îú‚îÄ‚îÄ .env           # Environment configuration
‚îÇ   ‚îî‚îÄ‚îÄ index.php      # Framework bootstrap
‚îÇ
‚îú‚îÄ‚îÄ public/            # Public assets (CSS, JS, images)
‚îú‚îÄ‚îÄ index.php          # Main entry point or micro-app
‚îú‚îÄ‚îÄ login/             # Independent app
‚îÇ   ‚îî‚îÄ‚îÄ index.php
‚îú‚îÄ‚îÄ set-lang/          # Language switcher
‚îÇ   ‚îî‚îÄ‚îÄ index.php
‚îî‚îÄ‚îÄ .htaccess          # Deny access to /app and route all requests
</code></pre>
        </section>

        <!-- Routing -->
        <section id="routing" class="mt-4">
          <h2>Routing</h2>
          <p>
            Routes can be defined using the <code>$app->get()</code>, <code>$app->post()</code>,
            <code>$app->put()</code>, and <code>$app->delete()</code> methods. Each route accepts
            a callback, optional middlewares, and an optional CSRF flag for POST, PUT, and DELETE methods.
          </p>

          <pre><code class="language-php">&lt;?php
 //index.php 
include_once __DIR__."/app/index.php";

$app->get(callback: function($req, $res) use ($app) {
    return $app->render("home");
});

$app->post(callback: function($req, $res) use ($app) {
    return $app->jsonResponse(["success" => true]);
}, csrf: true);

$app->run();
</code></pre>
        </section>

        <!-- Validation -->
        <section id="validation" class="mt-4">
          <h2>Validation</h2>
          <p>
            LilaPHP provides a clean, declarative validation system using <strong>PHP 8 attributes</strong>
            inside model classes that extend <code>BaseModel</code>.
            This allows request validation to stay organized, type-safe, and easy to read.
          </p>

          <h3>üß© Example: Validating a Login Form</h3>
          <pre><code class="language-php">
// login/index.php
use Core\BaseModel;
use Core\Field;

class LoginModel extends BaseModel
{
    #[Field(required: true, format: "email")]
    public string $email;

    #[Field(required: true, min_length: 6)]
    public string $password;
}

$app->post(
    callback: fn($req, $res) => $app->jsonResponse(["success" => true]),
    middlewares: [
        fn($req, $res) => new LoginModel(data: $req)
    ],
    csrf: true
);
</code></pre>

          <p>
            When this route receives a POST request, LilaPHP automatically validates the input data
            using the attributes defined in the <code>LoginModel</code>.
            If any validation fails, a structured JSON or HTML response is automatically returned with error details.
          </p>

          <h3>üåê Multi-language Validation Support</h3>
          <p>
            The validation system supports multiple languages out of the box ‚Äî including
            <strong>English (eng)</strong>, <strong>Spanish (esp)</strong>,
            <strong>Brazilian Portuguese (bra)</strong>, and <strong>Portuguese (por)</strong>.
          </p>

          <p>
            The active validation language is automatically detected from the framework context
            (for example, user session or <code>.env</code> configuration), and defaults to English.
          </p>

          <p>
            Each validation rule message is defined inside <code>BaseModel::$defaultMessages</code>,
            containing localized error messages for every supported language.
          </p>

          <h4>Example (English vs. Spanish)</h4>
          <pre><code class="language-json">{
  "eng": {
    "required": "Field ':field' is required",
    "min_length": "Field ':field' must be at least :min_length characters long"
  },
  "esp": {
    "required": "El campo ':field' es obligatorio",
    "min_length": "El campo ':field' debe tener al menos :min_length caracteres"
  }
}
</code></pre>

          <h3>üõ†Ô∏è Custom Messages</h3>
          <p>
            You can override any default validation message directly in the attribute declaration
            using the <code>messages</code> parameter:
          </p>

          <pre><code class="language-php">#[Field(required: true, messages: [
  "required" => "Please enter your email address."
])]
public string $email;</code></pre>

          <h3>üí° Supported Validation Rules</h3>
          <p>
            LilaPHP currently supports a wide range of built-in validation rules:
          </p>

          <ul class="list-disc pl-6">
            <li><code>required</code> ‚Äì Field must not be empty</li>
            <li><code>min</code>, <code>max</code> ‚Äì Numeric value limits</li>
            <li><code>min_length</code>, <code>max_length</code>, <code>length</code> ‚Äì String length limits</li>
            <li><code>format</code> ‚Äì Predefined format validation (<code>email</code>, <code>ip</code>,
              <code>url</code>, <code>uuid</code>, <code>number</code>, <code>date</code>, <code>boolean</code>, etc.)
            </li>
            <li><code>pattern</code> ‚Äì Custom regex pattern validation</li>
          </ul>

          <p>
            When a validation fails, a <code>ValidationException</code> is thrown and handled automatically
            by the framework, returning an appropriate response with localized messages.
          </p>

          <h3>üßæ Example of Validation Error Response (JSON)</h3>
          <pre><code class="language-json">{
  "success": false,
  "error": true,
  "message": "Field 'email' must be a valid email address, Field 'password' must be at least 6 characters long.",
  "errors": {
    "email": ["Field 'email' must be a valid email address"],
    "password": ["Field 'password' must be at least 6 characters long"]
  }
}</code></pre>

          <p>
            This makes the validation layer both <strong>declarative</strong> and <strong>localization-aware</strong>,
            ensuring consistent, user-friendly feedback in any supported language.
          </p>
        </section>


        <!-- Sessions -->
        <section id="sessions" class="mt-4">
          <h2>Sessions</h2>
          <p>LilaPHP provides a simple and secure session API.</p>
          <pre><code class="language-php">$app->setSession("user_id", 1);
$user = $app->getSession("user_id");
$app->removeSession("user_id");
</code></pre>
        </section>

        <!-- Localization -->
        <section id="localization" class="mt-4">
          <h2>üåç Localization & Translations</h2>
          <p>
            LilaPHP includes native support for multi-language applications.
            The default language is defined in the <code>.env</code> file:
          </p>

          <pre><code class="language-env">LANG_DEFAULT="esp"</code></pre>

          <p>
            However, it can be changed dynamically at runtime ‚Äî for example, when the user
            selects a different language from a menu or a query parameter.
          </p>

          <h3>üîÅ Example: Changing the language dynamically</h3>
          <pre><code class="language-php">&lt;?php
$app->get(callback: function($req, $res) use ($app) {
    $lang = $_GET['lang'] ?? $app->getLangDefault();
    $app->setSession("lang", $lang);
    $back = $_SERVER['HTTP_REFERER'] ?? '/';
    $app->redirect($back);
});</code></pre>

          <p>
            This route detects the <code>?lang=esp</code> or <code>?lang=eng</code> parameter,
            stores it in the session, and redirects the user back to the previous page.
          </p>

          <h3>üóÇ Translation files structure</h3>
          <p>
            Translations are stored inside <code>app/locales/</code>, one file per language:
          </p>

          <pre><code class="language-bash">app/
‚îú‚îÄ‚îÄ locales/
‚îÇ   ‚îú‚îÄ‚îÄ esp.php
‚îÇ   ‚îú‚îÄ‚îÄ eng.php
‚îÇ   ‚îú‚îÄ‚îÄ bra.php
‚îÇ   ‚îî‚îÄ‚îÄ por.php
</code></pre>

          <p>
            Each file returns an associative array containing translation keys and values.
          </p>

          <pre><code class="language-php">&lt;?php
// app/locales/eng.php
return [
  "welcome" => "Welcome!",
  "login" => [
    "title" => "Login",
    "email" => "Email address"
  ]
];</code></pre>

          <pre><code class="language-php">&lt;?php
// app/locales/esp.php
return [
  "welcome" => "¬°Bienvenido!",
  "login" => [
    "title" => "Iniciar sesi√≥n",
    "email" => "Correo electr√≥nico"
  ]
];</code></pre>

          <h3>üß© Using translations in Twig templates</h3>
          <p>
            Inside your Twig templates located in <code>app/templates/</code>,
            you can use the global <code>translate()</code> function to display localized text:
          </p>

          <pre><code class="language-twig">{# app/templates/index.twig #}
&lt;h1 class="mb-2"&gt;{{ translate("welcome") }}&lt;/h1&gt;

{# app/templates/login.twig #}
&lt;h2&gt;{{ translate("login.title") }}&lt;/h2&gt;
&lt;label&gt;{{ translate("login.email") }}&lt;/label&gt;
</code></pre>

          <p>
            The system automatically detects the active language from the session
            (<code>$_SESSION['lang']</code>), or falls back to the default language defined in
            <code>.env</code>.
            You can also force a specific language programmatically if needed.
          </p>

          <hr class="my-4 border-gray-300" />
          <p class="text-secondary">
            üåê Currently supported languages:
            <strong>Spanish (esp)</strong>, <strong>English (eng)</strong>,
            <strong>Brazilian Portuguese (bra)</strong>, and <strong>Portuguese (por)</strong>.
          </p>
        </section>


        <!-- Config -->
        <section id="config" class="mt-4">
          <h2>Environment Configuration (.env)</h2>
          <p>
            Your environment file controls application mode, debug options, URLs, localization, and paths.
          </p>

          <pre><code class="language-ini">TITLE_PROJECT="LilaPHP Framework"
DEBUG=false
VERSION_PROJECT="0.1"
VERSION_API="1"
PATH_LOGS="logs/"
PATH_LOCALES="locales/"
SECRET_KEY="mysecretkey"
URL_PROJECT="http://localhost:8000/"
LANG="eng"</code></pre>

          <p>
            When <code>DEBUG=true</code>, verbose error messages and detailed logging are enabled.
            In production, set it to <code>false</code> for performance and security.
          </p>
        </section>

        <!-- Security -->
        <section id="security" class="mt-4">
          <h2>Security & CSRF Protection</h2>
          <p>
            LilaPHP includes built-in mechanisms for security, input sanitization, and protection against
            cross-site request forgery (CSRF).
            When you define a route with <code>$app->post()</code>, <code>$app->put()</code>, or
            <code>$app->delete()</code>,
            you can simply pass <code>csrf: true</code> to enable CSRF validation automatically.
          </p>

          <pre><code class="language-php">
$app->post(
    callback: fn($req, $res) => $app->jsonResponse(["success" => true]),
    middlewares: [fn($req, $res) => new LoginModel(data: $req)],
    csrf: true
);
</code></pre>

          <p>
            When <code>csrf: true</code> is set, LilaPHP automatically:
          </p>

          <ul class="list-disc pl-6">
            <li>Generates a unique CSRF token and stores it in the session</li>
            <li>Provides a Twig helper <code>{{ csrf_input() }}</code> to include the hidden token in forms</li>
            <li>Validates the token on every POST, PUT, or DELETE request</li>
            <li>Rejects requests with invalid or missing tokens, returning a JSON or HTML error response</li>
          </ul>

          <h3>üß© Example: Secure Login Form</h3>
          <p>
            In your Twig template, simply include the CSRF token using the <code>csrf_input()</code> helper.
            You can also use <code>translate()</code> or <code>image()</code> helpers for localized text and optimized
            images.
          </p>

          <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;link rel="icon" href="{{ image('img/lila.png', 40, 0, 70, 'ico') }}" /&gt;
    &lt;title&gt;{{ title }}&lt;/title&gt;
    &lt;link rel="stylesheet" href="{{ asset('css/lila.css') }}" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;main class="container"&gt;
      &lt;article class="w-mx-400-px mt-4"&gt;
        &lt;h1&gt;{{ translate("login") }}&lt;/h1&gt;

        &lt;form onsubmit="Login(event)" method="POST"&gt;
          {{ csrf_input() }}
          &lt;div&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input type="email" name="email" required /&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;label&gt;Password&lt;/label&gt;
            &lt;input type="password" name="password" required /&gt;
          &lt;/div&gt;
          &lt;button type="submit" class="w-full"&gt;Login&lt;/button&gt;
        &lt;/form&gt;

        &lt;div id="messages" class="mt-4"&gt;&lt;/div&gt;
      &lt;/article&gt;

      &lt;div class="mt-4 flex justify-between gap-4"&gt;
        &lt;a href="/set-lang/?lang=eng"&gt;English&lt;/a&gt;
        &lt;a href="/set-lang/?lang=esp"&gt;Espa√±ol&lt;/a&gt;
        &lt;a href="/set-lang/?lang=br"&gt;Portuguese&lt;/a&gt;
      &lt;/div&gt;
    &lt;/main&gt;

    &lt;script&gt;
      async function Login(event) {
        event.preventDefault();
        const body = Object.fromEntries(new FormData(event.target));
        const r = await fetch("/login", {
          method: "POST",
          body: JSON.stringify(body),
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": body._csrf,
          },
          credentials: "include",
        });

        const response = await r.json();
        document.getElementById("messages").innerHTML =
          response.html || response.message || "";
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

          <p>
            The <code>X-CSRF-Token</code> header ensures that the token is validated even for JSON-based requests,
            offering protection beyond standard form submissions.
          </p>

          <h3>üß± Example: Endpoint Definition</h3>
          <pre><code class="language-php">&lt;?php
include_once "../app/index.php";

use Core\BaseModel;
use Core\Field;

class LoginModel extends BaseModel
{
    #[Field(required: true, format: "email")]
    public string $email;

    #[Field(required: true, min_length: 6)]
    public string $password;
}

$lang = $app->getSession(key: "lang", default: "es");

$app->get(callback: fn($req, $res) => $app->render("login"));

$app->post(
    callback: fn($req, $res) => $app->jsonResponse([
        "success" => true,
        "login" => false,
        "session" => $app->getSession("lang")
    ]),
    middlewares: [fn($req, $res) => new LoginModel(data: $req, lang: $lang)],
    csrf: true
);

$app->addMiddlewares(middlewares: [
    "before" => [fn($req, $res) => error_log("Custom before route")],
    "after" => [fn($req, $res) => error_log("Custom after route")]
]);

$app->run();
</code></pre>

          <h3>üîê Behind the Scenes</h3>
          <p>
            The <code>Security</code> core class is responsible for:
          </p>

          <ul class="list-disc pl-6">
            <li><strong>CSRF Token Generation:</strong> Tokens are cryptographically secure and stored in the session.
            </li>
            <li><strong>Automatic Token Injection:</strong> The <code>{{ csrf_input() }}</code> helper inserts the
              hidden field with the current token.</li>
            <li><strong>Server-side Validation:</strong> Each POST, PUT, or DELETE request is checked against the stored
              token.</li>
            <li><strong>Automatic Sanitization:</strong> All input data is sanitized before use.</li>
            <li><strong>Session Management:</strong> Sessions are securely configured using
              <code>session_set_cookie_params</code> with proper path, domain, and HTTP-only flags.
            </li>
            <li><strong>Error Logging:</strong> Security-related errors are logged with timestamps and file context for
              debugging.</li>
            <li><strong>CORS Support:</strong> Cross-Origin Resource Sharing can be enforced or disabled through
              configuration.</li>
          </ul>

          <p>
            This integrated security layer ensures that all requests in LilaPHP are verified, isolated, and safe by
            default.
          </p>
        </section>


        <!-- Twig Template Functions -->
        <section id="templates" class="mt-4">
          <h2>Twig Template Functions</h2>
          <p>
            LilaPHP extends Twig with built-in helper functions that enhance performance,
            SEO, and developer productivity. These helpers are globally available inside
            all templates without any additional configuration.
          </p>

          <ul>
            <li>
              <strong>asset(file)</strong> ‚Äî Returns a versioned and minified URL for
              static assets like CSS or JS. This ensures cache-busting and automatic
              compression for optimal performance.
            </li>
            <li>
              <strong>image(file, width, height, quality, type)</strong> ‚Äî Dynamically
              generates optimized images (WebP or ICO) for faster loading and improved SEO.
              You can specify width, height, compression quality, and output type.
            </li>
            <li>
              <strong>url(path)</strong> ‚Äî Returns the full absolute project URL. Useful
              for canonical links, Open Graph metadata, or redirects.
            </li>
            <li>
              <strong>csrf_input()</strong> ‚Äî Outputs the hidden CSRF token input field
              automatically for secure POST, PUT, or DELETE requests.
            </li>
            <li>
              <strong>translate(key)</strong> or <strong>__(key)</strong> ‚Äî Returns
              translated strings from your locale files based on the current session
              language.
            </li>
          </ul>

          <p>
            These helpers are automatically registered during boot and work seamlessly with
            LilaPHP‚Äôs caching system. They reduce file size, improve caching efficiency,
            and enhance SEO through minified assets and optimized metadata generation.
          </p>

          <h3 class="mt-4">Examples</h3>
          <pre><code class="language-html">&lt;link
  rel="icon"
  type="image/png"
  href="{{ image('img/lila.png', 40, 0, 70, 'ico') }}"
/&gt;

&lt;link rel="stylesheet" href="{{ asset('css/lila.css') }}" /&gt;

&lt;img src="{{ image('img/lila.png', 200) }}" width="200" alt="LilaPHP" /&gt;
</code></pre>
        </section>
        <!-- SEO -->
        <section id="seo" class="mt-4">
          <h2>SEO Optimization</h2>
          <p>
            LilaPHP‚Äôs template system automatically handles SEO-friendly optimizations.
            Twig templates can dynamically include meta tags, Open Graph data, and favicon
            links. Use the <code>image()</code> helper to generate lightweight WebP icons
            automatically.
          </p>

          <p>
            When <code>DEBUG=false</code> is set in your <code>.env</code> file, LilaPHP
            automatically compiles and caches minified <code>.js</code>, <code>.css</code>,
            and image files into <code>public/cache</code>. This process is executed once,
            ensuring top performance and improved SEO.
          </p>

          <p>
            All rendered HTML is also minified by default to reduce file size and protect
            against injection attacks. Twig template caching further boosts speed and
            security by storing compiled templates for faster rendering.
          </p>

          <ul>
            <li>Automatic HTML, JS, and CSS minification</li>
            <li>Optimized WebP image generation</li>
            <li>CSRF protection and secure escaping</li>
            <li>Built-in template caching for maximum performance</li>
          </ul>
        </section>





        <!-- Performance -->
        <section id="performance" class="mt-4">
          <h2>Performance</h2>
          <p>
            When <code>DEBUG=false</code>, LilaPHP automatically minifies your CSS and JS via <code>asset()</code>.
            Caching, lazy translation loading, and optimized image generation further enhance performance.
          </p>
        </section>

        <!-- Core App -->
        <section id="coreapp" class="mt-4">
          <h2>The <code>App</code> Core</h2>
          <p>
            The <code>App</code> class is the heart of LilaPHP. It initializes configuration, handles routing,
            executes middleware, manages sessions, and responds to the client.
          </p>

          <ul>
            <li>Automatic loading of <code>.env</code> settings</li>
            <li>Built-in error and exception logging</li>
            <li>Integrated CSRF and sanitization layer</li>
            <li>Simple methods for <code>render()</code>, <code>jsonResponse()</code>, and <code>redirect()</code></li>
            <li>Before/after middleware support for every route</li>
          </ul>

          <pre><code class="language-php">$app->redirect('/dashboard');
$app->jsonResponse(['ok' => true]);
$app->render('home');</code></pre>
        </section>
        <!-- Production -->
        <section id="production" class="mt-4">
          <h2>Production Environment</h2>
          <p>
            LilaPHP is built to run efficiently and securely in any production setup ‚Äî
            whether you‚Äôre using <strong>NGINX</strong>, <strong>Apache</strong>,
            <strong>FrankenPHP</strong>, <strong>Swoole</strong>, a
            <strong>VPS</strong>, or even a <strong>shared hosting environment</strong>.
          </p>

          <h3>üîí Restricting Sensitive Directories</h3>
          <p>
            For security reasons, access to the <code>/app</code> directory must be
            denied in production. This directory contains the framework core, templates,
            environment files, and other internal components that should never be served
            publicly.
          </p>

          <h4>‚û°Ô∏è NGINX Configuration</h4>
          <pre><code class="language-nginx">server {
    listen 80;
    server_name example.com;
    root /var/www/LilaPHP/;

    index index.php;
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    # Deny access to core app directory
    location /app {
        deny all;
    }

    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/run/php/php8.2-fpm.sock;
    }

    error_log /var/log/nginx/lilaphp_error.log;
    access_log /var/log/nginx/lilaphp_access.log;
}</code></pre>

          <h4>‚û°Ô∏è Apache (.htaccess)</h4>
          <p>
            In Apache, the <code>.htaccess</code> file already protects <code>/app</code>
            automatically. Ensure you include this rule in your root folder:
          </p>

          <pre><code class="language-apache">&lt;IfModule mod_rewrite.c&gt;
  RewriteEngine On
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule ^ index.php [L]
&lt;/IfModule&gt;

# Deny direct access to /app
&lt;Directory "app"&gt;
  Order allow,deny
  Deny from all
&lt;/Directory&gt;</code></pre>

          <h3>‚öôÔ∏è Environment Configuration</h3>
          <p>
            Your <code>.env</code> file should set <strong>DEBUG=false</strong> in
            production to disable error traces and enable optimized performance:
          </p>

          <pre><code class="language-ini">DEBUG=false</code></pre>

          <p>
            LilaPHP automatically detects this setting and loads only the required
            components for each route, avoiding unnecessary overhead.
          </p>

          <h3>üöÄ Optimized Loading</h3>
          <p>
            Unlike heavier frameworks that bootstrap the entire stack for every request,
            LilaPHP only loads what each endpoint needs ‚Äî templates, routes, or
            middleware ‚Äî ensuring minimal memory footprint and top performance.
          </p>

          <p>
            With this setup, your application runs cleanly and securely across any PHP
            runtime ‚Äî whether you‚Äôre deploying on:
          </p>

          <ul class="list-disc pl-6">
            <li>üíª Local network or shared hosting</li>
            <li>‚öôÔ∏è VPS or cloud instance (NGINX, Apache)</li>
            <li>üß© Modern runtimes like FrankenPHP or Swoole</li>
          </ul>

          <p class="text-secondary mt-4">
            ‚úÖ Ready for production ‚Äî LilaPHP handles routing, caching, and security
            with zero configuration once <code>DEBUG=false</code>.
          </p>
        </section>


      </div>
       </div>
    </div>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>
    hljs.highlightAll();

  </script>

</body>

</html>